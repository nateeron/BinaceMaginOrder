<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Binance Cross Margin Orders</title>
  <style>
    :root {
      --bg: #0f1419;
      --card: #1a2332;
      --border: #2d3a4d;
      --text: #e6edf3;
      --muted: #8b949e;
      --buy: #3fb950;
      --sell: #f85149;
      --accent: #173251;
    }
    * { box-sizing: border-box; }
    body {
      font-family: 'Segoe UI', system-ui, sans-serif;
      background: var(--bg);
      color: var(--text);
      margin: 0;
      padding: 24px;
      min-height: 100vh;
    }
    h1 {
      font-size: 1.5rem;
      font-weight: 600;
      margin-bottom: 24px;
      color: var(--text);
    }
    .summary-row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 16px;
      margin-bottom: 24px;
    }
    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 20px;
    }
    .card-title {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--muted);
      margin-bottom: 8px;
    }
    .card-value {
      font-size: 1.5rem;
      font-weight: 600;
    }
    .card-value.buy { color: var(--buy); }
    .card-value.sell { color: var(--sell); }
    .card-value.net { color: var(--accent); }
    .toolbar {
      margin-bottom: 16px;
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }
    button {
      background: var(--accent);
      color: #fff;
      border: none;
      padding: 10px 20px;
      border-radius: 8px;
      font-size: 14px;
      cursor: pointer;
      font-weight: 500;
    }
    button:hover { opacity: 0.9; }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .table-wrap {
      overflow-x: auto;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: var(--card);
    }
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 14px;
    }
    th, td {
      padding: 12px 16px;
      text-align: left;
      border-bottom: 1px solid var(--border);
    }
    th {
      background: rgba(0,0,0,0.2);
      font-weight: 600;
      color: var(--muted);
      white-space: nowrap;
    }
    tr:last-child td { border-bottom: none; }
    tr:hover td { background: rgba(255,255,255,0.03); }
    .side-buy { color: var(--buy); }
    .side-sell { color: var(--sell); }
    .status { text-transform: uppercase; font-size: 12px; }
    .error {
      background: rgba(248,81,73,0.15);
      border: 1px solid var(--sell);
      color: #f85149;
      padding: 16px;
      border-radius: 8px;
      margin-bottom: 16px;
    }
    .loading { opacity: 0.7; pointer-events: none; }
    .summary-cards { margin-top: 24px; }
    .summary-cards h2 { font-size: 1rem; margin-bottom: 12px; color: var(--muted); }
    .summary-cards-grid { display: flex; flex-wrap: wrap; gap: 12px; }
    .summary-card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      min-width: 180px;
      cursor: pointer;
      transition: border-color 0.2s, box-shadow 0.2s;
    }
    .summary-card:hover { border-color: var(--accent); }
    .summary-card.selected { border-color: var(--accent); box-shadow: 0 0 0 2px rgba(88,166,255,0.3); }
    .summary-card { position: relative; }
    .summary-card .row-label { font-size: 0.75rem; color: var(--muted); margin-bottom: 4px; }
    .summary-card .row-num { font-size: 1.25rem; font-weight: 600; margin-bottom: 8px; }
    .btn-close-card {
      position: absolute;
      top: 8px;
      right: 8px;
      width: 28px;
      height: 28px;
      padding: 0;
      border-radius: 6px;
      border: none;
      background: rgba(248, 81, 73, 0.2);
      color: var(--sell);
      cursor: pointer;
      font-size: 14px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
    }
    .btn-close-card:hover { background: rgba(248, 81, 73, 0.35); }
    .summary-card .card-line { font-size: 13px; margin: 4px 0; }
    .summary-card .card-line span { color: var(--muted); }
    .summary-card-actions { margin-top: 10px; display: flex; align-items: center; gap: 8px; }
    .btn-save-mini {
      width: 32px; height: 32px;
      padding: 0;
      border-radius: 8px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      background: var(--buy);
      color: #fff;
      border: none;
      cursor: pointer;
      font-size: 16px;
    }
    .btn-save-mini:hover { opacity: 0.9; }
    .table-wrap .th-select { width: 40px; text-align: center; }
    .table-wrap .td-select { text-align: center; }
    .table-wrap .th-pair { width: 56px; text-align: center; }
    .table-wrap .td-pair { text-align: center; font-weight: 600; color: var(--accent); }
    tr.tr-pair-start td { border-top: 2px solid rgba(88, 166, 255, 0.5); }
    tr.tr-pair-end td { border-bottom: 2px solid rgba(88, 166, 255, 0.5); }
    tr.tr-selected td { background: rgba(88, 166, 255, 0.15); }
    tr.tr-selectable { cursor: pointer; }
    tr.tr-highlight td { background: rgba(88, 166, 255, 0.2); }
    tr.tr-matched td { background: rgb(6 11 16 / 18%); color: #555555; font-weight: normal; }
    tr.tr-matched td.side-buy { color: var(--buy); }
    tr.tr-matched td.side-sell { color: var(--sell); }
    .table-wrap .td-price-avg { color: #dbaa22; }
    tr.tr-side-buy .td-quantity, tr.tr-side-buy .td-qty-filled { color: #e6a870; }
    tr.tr-side-sell .td-quantity, tr.tr-side-sell .td-qty-filled { color: #e2972f; }
    .table-wrap .td-quote-filled { color: #29beb5; }
    .table-wrap .td-profit { color: #3c8b42; }
    .table-wrap .td-type-market { color: #7378f1; }
    .table-wrap .td-type-limit { color: #b079e2; }
    tr.tr-side-buy td { background: #0f1b0db0; }
    tr.tr-side-sell td { background: #221111; }
    tr.tr-matched.tr-side-buy td { background: rgb(6 11 16 / 18%); }
    tr.tr-matched.tr-side-sell td { background: rgb(6 11 16 / 18%); }
    .chart-wrap {
      margin-bottom: 24px;
      padding: 16px;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 12px;
    }
    .chart-wrap h2 { font-size: 1rem; margin: 0 0 12px 0; color: var(--muted); }
    .chart-wrap .chart-container { position: relative; height: 320px; }
    .btn-reset-zoom {
      padding: 6px 12px;
      font-size: 13px;
      background: var(--border);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 6px;
      cursor: pointer;
    }
    .btn-reset-zoom:hover { background: #2d3a4d; }
    .toolbar-checkbox { display: inline-flex; align-items: center; gap: 8px; cursor: pointer; font-size: 14px; color: var(--text); }
    .toolbar-checkbox input { cursor: pointer; }
    .filter-row { display: flex; flex-wrap: wrap; align-items: center; gap: 12px; margin-bottom: 12px; }
    .filter-row label { display: inline-flex; align-items: center; gap: 6px; font-size: 13px; color: var(--muted); }
    .filter-row input[type="number"] { width: 140px; padding: 8px 10px; border: 1px solid var(--border); border-radius: 6px; background: var(--card); color: var(--text); font-size: 13px; }
    .filter-row input[type="datetime-local"] { width: 180px; padding: 8px 10px; border: 1px solid var(--border); border-radius: 6px; background: var(--card); color: var(--text); font-size: 13px; }
    .filter-row select { width: 120px; padding: 8px 10px; border: 1px solid var(--border); border-radius: 6px; background: var(--card); color: var(--text); font-size: 13px; }
    .filter-row input::placeholder { color: var(--muted); opacity: 0.8; }
  </style>
</head>
<body>
  <h1>Binance Cross Margin Orders</h1>

  <div class="summary-row" id="summary">
    <div class="card">
      <div class="card-title">Quantity BUY Total</div>
      <div class="card-value buy" id="qty-buy">0</div>
    </div>
    <div class="card">
      <div class="card-title">Quantity SELL Total</div>
      <div class="card-value sell" id="qty-sell">0</div>
    </div>
    <div class="card">
      <div class="card-title">BuyAll ‚àí SellAll (Quantity)</div>
      <div class="card-value net" id="qty-net">0</div>
    </div>
    <div class="card">
      <div class="card-title">quoteQuantityFilled BUY Total</div>
      <div class="card-value buy" id="quote-buy">0</div>
    </div>
    <div class="card">
      <div class="card-title">quoteQuantityFilled SELL Total</div>
      <div class="card-value sell" id="quote-sell">0</div>
    </div>
    <div class="card">
      <div class="card-title">BuyAll ‚àí SellAll (Quote)</div>
      <div class="card-value net" id="quote-net">0</div>
    </div>
  </div>

  <div class="filter-row">
    <label>ConfigId <input type="number" id="filter-config-id" value="20" min="0" step="1" /></label>
    <label>Symbol <select id="filter-symbol">
      <option value="XRPUSDT">XRPUSDT</option>
      <option value="BNBUSDT">BNBUSDT</option>
      <option value="BTCUSDT">BTCUSDT</option>
    </select></label>
    <label>StartTime <input type="datetime-local" id="filter-start-time" /></label>
    <label>EndTime <input type="datetime-local" id="filter-end-time" /></label>
    <label>Limit <input type="number" id="filter-limit" value="1000" min="1" max="1000" /></label>
    <button type="button" id="btn-search">Search</button>
  </div>
  <div class="toolbar">
    <button type="button" id="btn-new-summary">New Summary</button>
    <button type="button" id="btn-export-excel">Export Excel</button>
    <button type="button" id="btn-export-csv">Export CSV / Google Sheets</button>
    <label class="toolbar-checkbox">
      <input type="checkbox" id="chk-match-pairs" />
      <span>‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà Buy=Sell (Quantity) ‚Äî ‡πÅ‡∏™‡∏î‡∏á‡∏ß‡πà‡∏≤‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß</span>
    </label>
  </div>

  <div id="error" class="error" style="display: none;"></div>

  <div class="chart-wrap">
    <div style="display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 8px; margin-bottom: 12px;">
      <h2 style="margin: 0;">Price AVG by Create Time (FILLED only) ‚Äî click table row to highlight</h2>
      <button type="button" id="btn-reset-zoom" class="btn-reset-zoom">Reset zoom</button>
    </div>
    <div class="chart-container">
      <canvas id="chart-canvas"></canvas>
    </div>
    <p style="margin: 8px 0 0 0; font-size: 12px; color: var(--muted);">Scroll ‡∏ã‡∏π‡∏° ¬∑ ‡∏Ñ‡∏•‡∏¥‡∏Å‡∏Ñ‡πâ‡∏≤‡∏á‡πÅ‡∏•‡πâ‡∏ß‡∏•‡∏≤‡∏Å‡πÄ‡∏°‡∏≤‡∏™‡πå‡πÄ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤ (‡πÅ‡∏û‡∏ô)</p>
  </div>

  <div class="summary-cards">
    <h2>Saved summaries</h2>
    <div class="summary-cards-grid" id="summary-cards"></div>
  </div>

  <div class="table-wrap">
    <table>
      <thead>
        <tr id="thead-row">
          <th class="th-pair" id="th-pair" style="display: none;">‡∏Ñ‡∏π‡πà</th>
          <th>Order ID</th>
          <th>Symbol</th>
          <th>Side</th>
          <th>Type</th>
          <th>Status</th>
          <th>Quantity</th>
          <th>Price</th>
          <th>Qty Filled</th>
          <th>Quote Filled</th>
          <th>‡∏Å‡∏≥‡πÑ‡∏£</th>
          <th>Price AVG</th>
          <th>TP%</th>
          <th>Create Time</th>
          <th>Update Time</th>
        </tr>
      </thead>
      <tbody id="tbody">
        <tr><td colspan="14" style="text-align: center; color: var(--muted);">Loading‚Ä¶</td></tr>
      </tbody>
    </table>
  </div>

  <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
  <script>
    const API_URL = 'http://localhost:5081';
    const REQ_BASE = { OrderId: null };
    function getReq() {
      const configEl = document.getElementById('filter-config-id');
      const symbolEl = document.getElementById('filter-symbol');
      const startEl = document.getElementById('filter-start-time');
      const endEl = document.getElementById('filter-end-time');
      const limitEl = document.getElementById('filter-limit');
      const configId = configEl ? (parseInt(configEl.value, 10) || 0) : 20;
      const symbol = symbolEl && symbolEl.value ? symbolEl.value : 'XRPUSDT';
      const startVal = startEl && startEl.value ? startEl.value.trim() : '';
      const endVal = endEl && endEl.value ? endEl.value.trim() : '';
      const limitVal = limitEl ? (parseInt(limitEl.value, 10) || 1000) : 1000;
      const startMs = startVal === '' ? null : (new Date(startVal).getTime() || null);
      const endMs = endVal === '' ? null : (new Date(endVal).getTime() || null);
      return {
        ...REQ_BASE,
        ConfigId: configId,
        Symbol: symbol,
        StartTime: isNaN(startMs) ? null : startMs,
        EndTime: isNaN(endMs) ? null : endMs,
        Limit: Math.min(1000, Math.max(1, limitVal))
      };
    }

    const SUM1_KEY = 'binance_sum1';
    let sum1 = [];
    let selectedCardRow = null;
    let lastOrders = [];
    let chartInstance = null;
    let highlightedOrderId = null;
    let matchedOrderIds = new Set();
    let showMatchedPairs = false;

    const el = {
      tbody: document.getElementById('tbody'),
      theadRow: document.getElementById('thead-row'),
      error: document.getElementById('error'),
      btnNewSummary: document.getElementById('btn-new-summary'),
      summaryCards: document.getElementById('summary-cards'),
      qtyBuy: document.getElementById('qty-buy'),
      qtySell: document.getElementById('qty-sell'),
      qtyNet: document.getElementById('qty-net'),
      quoteBuy: document.getElementById('quote-buy'),
      quoteSell: document.getElementById('quote-sell'),
      quoteNet: document.getElementById('quote-net')
    };

    function priceAvgOrder(o) {
      const q = Number(o.quantityFilled ?? o.quantity ?? 0) || 0;
      const quote = Number(o.quoteQuantityFilled ?? 0) || 0;
      return q ? quote / q : 0;
    }
    const crosshairPlugin = {
      id: 'chartCrosshair',
      afterDraw(chart) {
        const crosshair = chart.crosshair;
        if (!crosshair || !chart.chartArea) return;
        const { x, y } = crosshair;
        const area = chart.chartArea;
        if (x < area.left || x > area.right || y < area.top || y > area.bottom) return;
        const ctx = chart.ctx;
        ctx.save();
        ctx.strokeStyle = 'rgba(139, 148, 158, 0.7)';
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 4]);
        ctx.beginPath();
        ctx.moveTo(x, area.top);
        ctx.lineTo(x, area.bottom);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(area.left, y);
        ctx.lineTo(area.right, y);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.restore();
      }
    };
    if (typeof Chart !== 'undefined') Chart.register(crosshairPlugin);
    let _crosshairOnMove = null;
    let _crosshairOnLeave = null;
    let _crosshairOnDown = null;
    let _crosshairOnUp = null;
    let _chartPanning = false;
    function chartClientToX(clientX) {
      const canvas = chartInstance.canvas;
      const rect = canvas.getBoundingClientRect();
      const scale = canvas.width / rect.width;
      const pixelX = (clientX - rect.left) * scale;
      const xScale = chartInstance.scales.x;
      return xScale.getValueForPixel(pixelX);
    }
    function bindChartCrosshair() {
      const canvas = document.getElementById('chart-canvas');
      if (!canvas || !chartInstance) return;
      if (_crosshairOnMove) {
        canvas.removeEventListener('mousemove', _crosshairOnMove);
        canvas.removeEventListener('mouseleave', _crosshairOnLeave);
        canvas.removeEventListener('mousedown', _crosshairOnDown);
        canvas.removeEventListener('mouseup', _crosshairOnUp);
        window.removeEventListener('mouseup', _crosshairOnUp);
      }
      _crosshairOnMove = (e) => {
        if (_chartPanning && chartInstance._panStart != null) {
          const xVal = chartClientToX(e.clientX);
          const delta = chartInstance._panStart.xVal - xVal;
          const newMin = chartInstance._panStart.min + delta;
          const newMax = chartInstance._panStart.max + delta;
          if (!chartInstance.options.scales) chartInstance.options.scales = {};
          if (!chartInstance.options.scales.x) chartInstance.options.scales.x = {};
          chartInstance.options.scales.x.min = newMin;
          chartInstance.options.scales.x.max = newMax;
          chartInstance.crosshair = null;
          chartInstance.update('none');
          return;
        }
        if (_chartPanning) return;
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        chartInstance.crosshair = {
          x: (e.clientX - rect.left) * scaleX,
          y: (e.clientY - rect.top) * scaleY
        };
        chartInstance.update('none');
      };
      _crosshairOnLeave = () => {
        _chartPanning = false;
        chartInstance._panStart = null;
        chartInstance.crosshair = null;
        chartInstance.update('none');
      };
      _crosshairOnDown = (e) => {
        const xScale = chartInstance.scales.x;
        if (!xScale) return;
        const xVal = chartClientToX(e.clientX);
        const area = chartInstance.chartArea;
        const rect = canvas.getBoundingClientRect();
        const scale = canvas.width / rect.width;
        const px = (e.clientX - rect.left) * scale;
        if (area && px >= area.left && px <= area.right) {
          _chartPanning = true;
          chartInstance._panStart = {
            xVal: xVal,
            min: xScale.min,
            max: xScale.max
          };
        }
      };
      _crosshairOnUp = () => {
        _chartPanning = false;
        chartInstance._panStart = null;
        chartInstance.crosshair = null;
        chartInstance.update('none');
      };
      canvas.addEventListener('mousemove', _crosshairOnMove);
      canvas.addEventListener('mouseleave', _crosshairOnLeave);
      canvas.addEventListener('mousedown', _crosshairOnDown);
      canvas.addEventListener('mouseup', _crosshairOnUp);
      window.addEventListener('mouseup', _crosshairOnUp);
    }
    function updateChart(orders) {
      const filled = (orders || []).filter(o => (o.status || '').toUpperCase() === 'FILLED');
      const buyOrders = filled.filter(o => (o.side || '').toUpperCase() === 'BUY');
      const sellOrders = filled.filter(o => (o.side || '').toUpperCase() === 'SELL');
      const toPoint = o => {
        const ct = o.createTime;
        const createTimeStr = ct ? (function(d) { try { const x = new Date(d); return isNaN(x.getTime()) ? d : x.toLocaleString(); } catch(_) { return d; } })(ct) : '‚Äî';
        return {
          x: new Date(ct).getTime(),
          y: priceAvgOrder(o),
          orderId: o.orderId,
          quantity: Number(o.quantityFilled ?? o.quantity ?? 0) || 0,
          quoteFilled: Number(o.quoteQuantityFilled ?? 0) || 0,
          priceAvg: priceAvgOrder(o),
          createTime: createTimeStr
        };
      };
      const buyPoints = buyOrders.map(toPoint);
      const sellPoints = sellOrders.map(toPoint);
      const allPoints = buyPoints.concat(sellPoints).sort((a, b) => a.x - b.x);
      const allOrderIds = buyPoints.map(p => p.orderId).concat(sellPoints.map(p => p.orderId));

      if (chartInstance) {
        const c = chartInstance.canvas;
        if (c && _crosshairOnMove) {
          c.removeEventListener('mousemove', _crosshairOnMove);
          c.removeEventListener('mouseleave', _crosshairOnLeave);
          c.removeEventListener('mousedown', _crosshairOnDown);
          c.removeEventListener('mouseup', _crosshairOnUp);
          window.removeEventListener('mouseup', _crosshairOnUp);
        }
        chartInstance.destroy();
      }
      const ctx = document.getElementById('chart-canvas');
      if (!ctx) return;
      const dsLine = {
        type: 'line',
        label: 'Price AVG',
        data: allPoints,
        borderColor: '#58a6ff',
        backgroundColor: 'transparent',
        borderWidth: 1.5,
        pointRadius: 0,
        pointHoverRadius: 0,
        fill: false,
        order: 0
      };
      const dsBuy = {
        label: 'BUY (FILLED)',
        data: buyPoints,
        borderColor: '#3fb950',
        backgroundColor: 'rgba(63, 185, 80, 0.6)',
        pointRadius: buyPoints.map(p => p.orderId === highlightedOrderId ? 10 : 5),
        pointHoverRadius: 8,
        order: 1,
        orderId: null
      };
      const dsSell = {
        label: 'SELL (FILLED)',
        data: sellPoints,
        borderColor: '#f85149',
        backgroundColor: 'rgba(248, 81, 73, 0.6)',
        pointRadius: sellPoints.map(p => p.orderId === highlightedOrderId ? 10 : 5),
        pointHoverRadius: 8,
        order: 2,
        orderId: null
      };
      chartInstance = new Chart(ctx, {
        type: 'scatter',
        data: { datasets: [dsLine, dsBuy, dsSell] },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { labels: { color: '#e6edf3' } },
            tooltip: {
              callbacks: {
                title: function(tooltipItems) {
                  const p = tooltipItems[0] && tooltipItems[0].raw;
                  return p ? ('Order ' + (p.orderId ?? '‚Äî')) : '';
                },
                label: function(ctx) {
                  if (ctx.datasetIndex === 0) return [];
                  const p = ctx.raw;
                  if (!p) return [];
                  return [
                    'Quantity: ' + formatNum(p.quantity),
                    'Quote Filled: ' + formatNum(p.quoteFilled),
                    'Price AVG: ' + formatNum(p.y),
                    'Create Time: ' + (p.createTime || '‚Äî')
                  ];
                }
              }
            },
            zoom: {
              zoom: {
                wheel: { enabled: true },
                pinch: { enabled: true },
                mode: 'x'
              },
              pan: {
                enabled: true,
                mode: 'x',
                modifierKey: null
              },
              limits: {
                x: { min: 'original', max: 'original' }
              }
            }
          },
          scales: {
            x: {
              type: 'linear',
              min: undefined,
              max: undefined,
              ticks: {
                color: '#8b949e',
                callback: function(v) {
                  const d = new Date(v);
                  return isNaN(d.getTime()) ? v : d.toLocaleString(undefined, { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' });
                }
              },
              title: { display: true, text: 'Create Time', color: '#8b949e' }
            },
            y: {
              ticks: { color: '#8b949e' },
              title: { display: true, text: 'Price AVG', color: '#8b949e' }
            }
          }
        }
      });
      if (highlightedOrderId != null && allOrderIds.indexOf(highlightedOrderId) !== -1) {
        let di = 1, ii = -1;
        if (buyPoints.findIndex(p => p.orderId === highlightedOrderId) !== -1) {
          ii = buyPoints.findIndex(p => p.orderId === highlightedOrderId);
          di = 1;
        } else {
          ii = sellPoints.findIndex(p => p.orderId === highlightedOrderId);
          di = 2;
        }
        chartInstance.setActiveElements([{ datasetIndex: di, index: ii }]);
        chartInstance.update();
      }
      bindChartCrosshair();
    }
    function updateChartHighlight(orderId) {
      highlightedOrderId = orderId;
      if (!chartInstance) return;
      const ds = chartInstance.data.datasets;
      if (ds[1]) ds[1].pointRadius = ds[1].data.map(p => (orderId != null && p.orderId === orderId) ? 10 : 5);
      if (ds[2]) ds[2].pointRadius = ds[2].data.map(p => (orderId != null && p.orderId === orderId) ? 10 : 5);
      if (orderId == null) {
        chartInstance.setActiveElements([]);
      } else {
        let di = -1, ii = -1;
        const i1 = ds[1] && ds[1].data.findIndex(p => p.orderId === orderId);
        if (i1 !== undefined && i1 !== -1) { di = 1; ii = i1; } else { const i2 = ds[2] && ds[2].data.findIndex(p => p.orderId === orderId); if (i2 !== undefined && i2 !== -1) { di = 2; ii = i2; } }
        if (di !== -1) chartInstance.setActiveElements([{ datasetIndex: di, index: ii }]);
        else chartInstance.setActiveElements([]);
      }
      chartInstance.update();
    }

    function exportToExcel() {
      if (typeof XLSX === 'undefined') {
        showError('Excel library not loaded. Check your connection.');
        return;
      }
      const wb = XLSX.utils.book_new();
      const summaryData = [
        ['Report Summary'],
        ['Quantity BUY Total', el.qtyBuy.textContent],
        ['Quantity SELL Total', el.qtySell.textContent],
        ['BuyAll ‚àí SellAll (Quantity)', el.qtyNet.textContent],
        ['quoteQuantityFilled BUY', el.quoteBuy.textContent],
        ['quoteQuantityFilled SELL', el.quoteSell.textContent],
        ['BuyAll ‚àí SellAll (Quote)', el.quoteNet.textContent]
      ];
      const wsSummary = XLSX.utils.aoa_to_sheet(summaryData);
      XLSX.utils.book_append_sheet(wb, wsSummary, 'Summary');
      if (lastOrders.length) {
        const orderHeaders = ['Order ID', 'Symbol', 'Side', 'Type', 'Status', 'Quantity', 'Price', 'Qty Filled', 'Quote Filled', 'Price AVG', 'Create Time', 'Update Time'];
        const orderRows = lastOrders.map(o => {
          const q = Number(o.quantityFilled ?? o.quantity ?? 0) || 0;
          const quote = Number(o.quoteQuantityFilled ?? 0) || 0;
          const avg = q ? quote / q : 0;
          return [o.orderId, o.symbol, o.side, o.type, o.status, o.quantity, o.price, o.quantityFilled, o.quoteQuantityFilled, avg, o.createTime, o.updateTime];
        });
        const wsOrders = XLSX.utils.aoa_to_sheet([orderHeaders, ...orderRows]);
        XLSX.utils.book_append_sheet(wb, wsOrders, 'Orders');
      }
      if (sum1.length) {
        const sumHeaders = ['Row', 'Select Count', 'Total Quantity', 'Price AVG BUY', 'Price AVG Sell'];
        const sumRows = sum1.map(s => [
          s.row,
          (s.selectedOrderIds && s.selectedOrderIds.length) || 0,
          s.totalQuantity ?? 0,
          s.priceAvgBuy ?? 0,
          s.priceAvgSell ?? 0
        ]);
        const wsSaved = XLSX.utils.aoa_to_sheet([sumHeaders, ...sumRows]);
        XLSX.utils.book_append_sheet(wb, wsSaved, 'Saved Summaries');
      }
      const name = 'binance-orders-' + new Date().toISOString().slice(0, 10) + '.xlsx';
      XLSX.writeFile(wb, name);
    }

    function exportToCsv() {
      const lines = [];
      const orderHeaders = ['Order ID', 'Symbol', 'Side', 'Type', 'Status', 'Quantity', 'Price', 'Qty Filled', 'Quote Filled', 'Price AVG', 'Create Time', 'Update Time'];
      lines.push(orderHeaders.map(escapeCsv).join(','));
      lastOrders.forEach(o => {
        const q = Number(o.quantityFilled ?? o.quantity ?? 0) || 0;
        const quote = Number(o.quoteQuantityFilled ?? 0) || 0;
        const avg = q ? quote / q : 0;
        const row = [o.orderId, o.symbol, o.side, o.type, o.status, o.quantity, o.price, o.quantityFilled, o.quoteQuantityFilled, avg, o.createTime, o.updateTime];
        lines.push(row.map(escapeCsv).join(','));
      });
      const csv = '\uFEFF' + lines.join('\r\n');
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'binance-orders-' + new Date().toISOString().slice(0, 10) + '.csv';
      a.click();
      URL.revokeObjectURL(a.href);
    }
    function escapeCsv(v) {
      if (v == null) return '';
      const s = String(v);
      if (/[",\r\n]/.test(s)) return '"' + s.replace(/"/g, '""') + '"';
      return s;
    }

    function loadSum1() {
      try {
        const raw = sessionStorage.getItem(SUM1_KEY);
        sum1 = raw ? JSON.parse(raw) : [];
      } catch (_) {
        sum1 = [];
      }
    }
    function saveSum1() {
      sessionStorage.setItem(SUM1_KEY, JSON.stringify(sum1));
    }
    function renderSummaryCards() {
      if (!sum1.length) {
        el.summaryCards.innerHTML = '<span style="color: var(--muted); font-size: 14px;">No saved summaries. Click "New Summary" to add one.</span>';
        return;
      }
      el.summaryCards.innerHTML = sum1.map((s, i) => {
        const selected = selectedCardRow === i;
        const count = (s.selectedOrderIds && s.selectedOrderIds.length) || 0;
        const rowLabel = selected ? `Save to row ${i}` : `row: ${i}`;
        return `<div class="summary-card ${selected ? 'selected' : ''}" data-row="${i}">
          <button type="button" class="btn-close-card" title="Delete card" data-delete-row="${i}">√ó</button>
          <div class="row-label">${rowLabel}</div>
          <div class="row-num">${i}</div>
          <div class="card-line">Select count: <span>${count}</span></div>
          <div class="card-line">Total Quantity: <span>${formatNum(s.totalQuantity)}</span></div>
          <div class="card-line">Price AVG BUY: <span>${formatNum(s.priceAvgBuy ?? 0)}</span></div>
          <div class="card-line">Price AVG Sell: <span>${formatNum(s.priceAvgSell ?? 0)}</span></div>
          ${selected ? `<div class="summary-card-actions">
            <button type="button" class="btn-save-mini" title="Save from selected orders" data-save-row="${i}">üíæ</button>
          </div>` : ''}
        </div>`;
      }).join('');
      el.summaryCards.querySelectorAll('.btn-close-card').forEach(btn => {
        btn.addEventListener('click', e => {
          e.stopPropagation();
          deleteCard(parseInt(btn.dataset.deleteRow, 10));
        });
      });
      el.summaryCards.querySelectorAll('.summary-card').forEach(card => {
        card.addEventListener('click', e => {
          if (e.target.closest('.btn-save-mini') || e.target.closest('.btn-close-card')) return;
          const row = parseInt(card.dataset.row, 10);
          if (selectedCardRow === row) {
            selectedCardRow = null;
            renderTable(lastOrders, false);
          } else {
            selectedCardRow = row;
            renderTable(lastOrders, true);
          }
          renderSummaryCards();
        });
      });
      el.summaryCards.querySelectorAll('.btn-save-mini').forEach(btn => {
        btn.addEventListener('click', e => {
          e.stopPropagation();
          saveFromSelection(parseInt(btn.dataset.saveRow, 10));
        });
      });
    }
    function deleteCard(rowIndex) {
      sum1.splice(rowIndex, 1);
      sum1.forEach((s, j) => { s.row = j; });
      if (selectedCardRow === rowIndex) {
        selectedCardRow = null;
        renderTable(lastOrders, false);
      } else if (selectedCardRow != null && selectedCardRow > rowIndex) {
        selectedCardRow--;
      }
      saveSum1();
      renderSummaryCards();
    }
    function saveFromSelection(cardRow) {
      const checkboxes = el.tbody.querySelectorAll('input[type="checkbox"]:checked');
      if (!checkboxes.length) return;
      const hasBuy = Array.from(checkboxes).some(cb => {
        const o = lastOrders[parseInt(cb.dataset.orderIndex, 10)];
        return o && (o.side || '').toUpperCase() === 'BUY';
      });
      let totalQty = 0, totalQuote = 0;
      let buyQty = 0, buyQuote = 0, sellQty = 0, sellQuote = 0;
      const selectedOrderIds = [];
      checkboxes.forEach(cb => {
        const idx = parseInt(cb.dataset.orderIndex, 10);
        const o = lastOrders[idx];
        if (!o) return;
        if (o.orderId != null) selectedOrderIds.push(o.orderId);
        const q = Number(o.quantityFilled ?? o.quantity ?? 0) || 0;
        const quote = Number(o.quoteQuantityFilled ?? 0) || 0;
        const isBuy = (o.side || '').toUpperCase() === 'BUY';
        if (isBuy) {
          totalQty += q;
          totalQuote += quote;
          buyQty += q;
          buyQuote += quote;
        } else {
          if (hasBuy) {
            totalQty -= q;
            totalQuote -= quote;
          } else {
            totalQty += q;
            totalQuote += quote;
          }
          sellQty += q;
          sellQuote += quote;
        }
      });
      const priceAvgBuy = buyQty ? buyQuote / buyQty : 0;
      const priceAvgSell = sellQty ? sellQuote / sellQty : 0;
      sum1[cardRow] = { row: cardRow, totalQuantity: totalQty, priceAvgBuy, priceAvgSell, selectedOrderIds };
      saveSum1();
      selectedCardRow = null;
      renderSummaryCards();
      renderTable(lastOrders, false);
    }

    function showError(msg) {
      el.error.textContent = msg;
      el.error.style.display = 'block';
    }
    function hideError() {
      el.error.style.display = 'none';
    }

    function formatNum(n) {
      if (n == null || n === '') return '‚Äî';
      const x = Number(n);
      return Number.isInteger(x) ? x : x.toFixed(4);
    }
    function formatDate(s) {
      if (!s) return '‚Äî';
      try {
        const d = new Date(s);
        return isNaN(d.getTime()) ? s : d.toLocaleString();
      } catch (_) { return s; }
    }

    function computeMatchedOrderIds(orders) {
      const set = new Set();
      if (!orders || !orders.length) return set;
      const qtyKey = (o) => {
        const q = Number(o.quantityFilled ?? o.quantity ?? 0) || 0;
        return (Math.round(q * 1e8) / 1e8).toString();
      };
      const buyByQty = {};
      const sellByQty = {};
      orders.forEach(o => {
        const key = qtyKey(o);
        const id = o.orderId;
        if (id == null) return;
        if ((o.side || '').toUpperCase() === 'BUY') {
          if (!buyByQty[key]) buyByQty[key] = []; buyByQty[key].push(o);
        } else {
          if (!sellByQty[key]) sellByQty[key] = []; sellByQty[key].push(o);
        }
      });
      Object.keys(buyByQty).forEach(key => {
        if (!sellByQty[key]) return;
        const buyList = buyByQty[key];
        const sellList = sellByQty[key];
        const n = Math.min(buyList.length, sellList.length);
        for (let i = 0; i < n; i++) {
          set.add(buyList[i].orderId);
          set.add(sellList[i].orderId);
        }
      });
      return set;
    }

    function orderQty(o) {
      return Number(o.quantityFilled ?? o.quantity ?? 0) || 0;
    }
    function roundQty(q) {
      return Math.round(q * 1e8) / 1e8;
    }
    /** Returns { displayList, matchedOrderIds }. ‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà 1-1 ‡πÅ‡∏•‡∏∞‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà‡∏´‡∏•‡∏≤‡∏¢‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå (‡πÄ‡∏ä‡πà‡∏ô 2 SELL + 2 BUY ‡∏ó‡∏µ‡πà‡∏ú‡∏•‡∏£‡∏ß‡∏° Quantity ‡πÄ‡∏ó‡πà‡∏≤‡∏Å‡∏±‡∏ô). */
    function computeMatchedPairsAndOrder(orders) {
      const matchedOrderIds = computeMatchedOrderIds(orders);
      const used = new Set();
      const qtyKey = (o) => roundQty(orderQty(o)).toString();
      const buyByQty = {};
      const sellByQty = {};
      orders.forEach((o, idx) => {
        const key = qtyKey(o);
        if ((o.side || '').toUpperCase() === 'BUY') {
          if (!buyByQty[key]) buyByQty[key] = []; buyByQty[key].push({ order: o, originalIndex: idx });
        } else {
          if (!sellByQty[key]) sellByQty[key] = []; sellByQty[key].push({ order: o, originalIndex: idx });
        }
      });
      const pairsRaw = [];
      Object.keys(buyByQty).forEach(key => {
        if (!sellByQty[key]) return;
        const buyList = buyByQty[key];
        const sellList = sellByQty[key];
        const n = Math.min(buyList.length, sellList.length);
        for (let i = 0; i < n; i++) {
          const buyQuote = Number(buyList[i].order.quoteQuantityFilled ?? 0) || 0;
          const sellQuote = Number(sellList[i].order.quoteQuantityFilled ?? 0) || 0;
          const pairProfit = sellQuote - buyQuote;
          const buyPriceAvg = priceAvgOrder(buyList[i].order);
          const sellPriceAvg = priceAvgOrder(sellList[i].order);
          const tpPercent = buyPriceAvg ? ((sellPriceAvg - buyPriceAvg) / buyPriceAvg) * 100 : null;
          pairsRaw.push([
            { order: buyList[i].order, originalIndex: buyList[i].originalIndex, pairProfit, tpPercent },
            { order: sellList[i].order, originalIndex: sellList[i].originalIndex, pairProfit, tpPercent }
          ]);
          used.add(buyList[i].order.orderId);
          used.add(sellList[i].order.orderId);
        }
      });
      const unbuy = [];
      const unsell = [];
      orders.forEach((o, idx) => {
        if (o.orderId == null || matchedOrderIds.has(o.orderId)) return;
        const item = { order: o, originalIndex: idx, qty: orderQty(o) };
        if ((o.side || '').toUpperCase() === 'BUY') unbuy.push(item); else unsell.push(item);
      });
      const usedInGroup = new Set(used);
      for (let i = 0; i < unbuy.length - 1; i++) {
        for (let j = i + 1; j < unbuy.length; j++) {
          if (usedInGroup.has(unbuy[i].order.orderId) || usedInGroup.has(unbuy[j].order.orderId)) continue;
          const sumB = roundQty(unbuy[i].qty + unbuy[j].qty);
          for (let k = 0; k < unsell.length - 1; k++) {
            for (let l = k + 1; l < unsell.length; l++) {
              if (usedInGroup.has(unsell[k].order.orderId) || usedInGroup.has(unsell[l].order.orderId)) continue;
              const sumS = roundQty(unsell[k].qty + unsell[l].qty);
              if (sumB !== sumS) continue;
              const bq1 = Number(unbuy[i].order.quoteQuantityFilled ?? 0) || 0;
              const bq2 = Number(unbuy[j].order.quoteQuantityFilled ?? 0) || 0;
              const sq1 = Number(unsell[k].order.quoteQuantityFilled ?? 0) || 0;
              const sq2 = Number(unsell[l].order.quoteQuantityFilled ?? 0) || 0;
              const pairProfit = (sq1 + sq2) - (bq1 + bq2);
              const buyAvg = (bq1 + bq2) / (unbuy[i].qty + unbuy[j].qty) || 0;
              const sellAvg = (sq1 + sq2) / (unsell[k].qty + unsell[l].qty) || 0;
              const tpPercent = buyAvg ? ((sellAvg - buyAvg) / buyAvg) * 100 : null;
              pairsRaw.push([
                { order: unbuy[i].order, originalIndex: unbuy[i].originalIndex, pairProfit, tpPercent },
                { order: unbuy[j].order, originalIndex: unbuy[j].originalIndex, pairProfit, tpPercent },
                { order: unsell[k].order, originalIndex: unsell[k].originalIndex, pairProfit, tpPercent },
                { order: unsell[l].order, originalIndex: unsell[l].originalIndex, pairProfit, tpPercent }
              ]);
              matchedOrderIds.add(unbuy[i].order.orderId);
              matchedOrderIds.add(unbuy[j].order.orderId);
              matchedOrderIds.add(unsell[k].order.orderId);
              matchedOrderIds.add(unsell[l].order.orderId);
              usedInGroup.add(unbuy[i].order.orderId);
              usedInGroup.add(unbuy[j].order.orderId);
              usedInGroup.add(unsell[k].order.orderId);
              usedInGroup.add(unsell[l].order.orderId);
              break;
            }
          }
        }
      }
      const unmatchedList = [];
      orders.forEach((o, idx) => {
        if (o.orderId != null && !matchedOrderIds.has(o.orderId)) {
          unmatchedList.push({ order: o, pairIndex: null, originalIndex: idx });
        }
      });
      pairsRaw.sort((a, b) => (Number(b[0].order.orderId) || 0) - (Number(a[0].order.orderId) || 0));
      const pairsList = [];
      pairsRaw.forEach((pair, idx) => {
        const pairNum = idx + 1;
        for (let p = 0; p < pair.length; p++) {
          pairsList.push({
            order: pair[p].order,
            pairIndex: pairNum,
            originalIndex: pair[p].originalIndex,
            pairProfit: pair[p].pairProfit,
            tpPercent: pair[p].tpPercent
          });
        }
      });
      const displayList = [...unmatchedList, ...pairsList];
      return { displayList, matchedOrderIds };
    }

    function updateSummary(orders) {
      let qtyBuy = 0, qtySell = 0, quoteBuy = 0, quoteSell = 0;
      for (const o of orders) {
        const q = Number(o.quantityFilled ?? o.quantity ?? 0) || 0;
        const quote = Number(o.quoteQuantityFilled ?? 0) || 0;
        if ((o.side || '').toUpperCase() === 'BUY') {
          qtyBuy += q;
          quoteBuy += quote;
        } else {
          qtySell += q;
          quoteSell += quote;
        }
      }
      el.qtyBuy.textContent = formatNum(qtyBuy);
      el.qtySell.textContent = formatNum(qtySell);
      el.qtyNet.textContent = formatNum(qtyBuy - qtySell);
      el.quoteBuy.textContent = formatNum(quoteBuy);
      el.quoteSell.textContent = formatNum(quoteSell);
      el.quoteNet.textContent = formatNum(quoteBuy - quoteSell);
    }

    function renderTable(orders, selectMode) {
      const sel = selectMode === true;
      const thPair = document.getElementById('th-pair');
      if (thPair) thPair.style.display = showMatchedPairs ? '' : 'none';
      const baseCols = 14 + (showMatchedPairs ? 1 : 0);
      if (!orders || !orders.length) {
        el.tbody.innerHTML = '<tr><td colspan="' + (sel ? baseCols + 1 : baseCols) + '" style="text-align: center; color: var(--muted);">No orders.</td></tr>';
        if (el.theadRow) {
          const existingSelect = el.theadRow.querySelector('.th-select');
          if (sel && !existingSelect) {
            const th = document.createElement('th');
            th.className = 'th-select';
            th.textContent = 'Select';
            el.theadRow.insertBefore(th, el.theadRow.firstChild);
          } else if (!sel && existingSelect) existingSelect.remove();
        }
        return;
      }
      if (el.theadRow) {
        const existingSelect = el.theadRow.querySelector('.th-select');
        if (sel && !existingSelect) {
          const th = document.createElement('th');
          th.className = 'th-select';
          th.textContent = 'Select';
          el.theadRow.insertBefore(th, el.theadRow.firstChild);
        } else if (!sel && existingSelect) {
          existingSelect.remove();
        }
      }
      const { displayList, matchedOrderIds: matchedIds } = showMatchedPairs ? computeMatchedPairsAndOrder(orders) : { displayList: orders.map((o, i) => ({ order: o, pairIndex: null, originalIndex: i, pairProfit: null, tpPercent: null })), matchedOrderIds: matchedOrderIds };
      if (showMatchedPairs) matchedOrderIds = matchedIds;
      const selectedIds = (sel && selectedCardRow != null && sum1[selectedCardRow]) ? (sum1[selectedCardRow].selectedOrderIds || []) : [];
      el.tbody.innerHTML = displayList.map((item) => {
        const o = item.order;
        const i = item.originalIndex;
        const side = (o.side || '').toUpperCase();
        const sideClass = side === 'BUY' ? 'side-buy' : 'side-sell';
        const checked = sel && o.orderId != null && selectedIds.indexOf(o.orderId) !== -1;
        const selectCell = sel ? `<td class="td-select"><input type="checkbox" data-order-index="${i}" ${checked ? 'checked' : ''} /></td>` : '';
        const isMatched = showMatchedPairs && o.orderId != null && matchedOrderIds.has(o.orderId);
        const pairStart = showMatchedPairs && item.pairIndex != null && side === 'BUY';
        const pairEnd = showMatchedPairs && item.pairIndex != null && side === 'SELL';
        const trSide = side === 'BUY' ? ' tr-side-buy' : ' tr-side-sell';
        const typeClass = (o.type || '').toUpperCase() === 'MARKET' ? ' td-type-market' : (o.type || '').toUpperCase() === 'LIMIT' ? ' td-type-limit' : '';
        const rowClass = (sel ? (' tr-selectable' + (checked ? ' tr-selected' : '')) : ' tr-clickable') + trSide + (isMatched ? ' tr-matched' : '') + (pairStart ? ' tr-pair-start' : '') + (pairEnd ? ' tr-pair-end' : '');
        const pairCell = showMatchedPairs ? `<td class="td-pair">${item.pairIndex != null ? item.pairIndex : '‚Äî'}</td>` : '';
        return `<tr data-order-index="${i}" data-order-id="${o.orderId ?? ''}" class="${rowClass}">
          ${selectCell}
          ${pairCell}
          <td>${o.orderId ?? '‚Äî'}</td>
          <td>${o.symbol ?? '‚Äî'}</td>
          <td class="${sideClass}">${o.side ?? '‚Äî'}</td>
          <td class="td-type${typeClass}">${o.type ?? '‚Äî'}</td>
          <td class="status">${o.status ?? '‚Äî'}</td>
          <td class="td-quantity">${formatNum(o.quantity)}</td>
          <td>${formatNum(o.price)}</td>
          <td class="td-qty-filled">${formatNum(o.quantityFilled)}</td>
          <td class="td-quote-filled">${formatNum(o.quoteQuantityFilled)}</td>
          <td class="td-profit">${item.pairProfit != null ? formatNum(item.pairProfit) : '‚Äî'}</td>
          <td class="td-price-avg">${formatNum((o.quantityFilled && Number(o.quantityFilled)) ? (Number(o.quoteQuantityFilled || 0) / Number(o.quantityFilled)) : null)}</td>
          <td>${item.tpPercent != null ? formatNum(item.tpPercent) + '%' : '‚Äî'}</td>
          <td>${formatDate(o.createTime)}</td>
          <td>${formatDate(o.updateTime)}</td>
        </tr>`;
      }).join('');
      if (!sel && orders.length) bindTableRowHighlight();
    }
    function bindTableRowHighlight() {
      el.tbody.querySelectorAll('tr.tr-clickable').forEach(tr => {
        tr.onclick = function(e) {
          const orderId = tr.dataset.orderId;
          if (orderId == null || orderId === '') return;
          highlightedOrderId = highlightedOrderId === orderId ? null : orderId;
          el.tbody.querySelectorAll('tr.tr-highlight').forEach(r => r.classList.remove('tr-highlight'));
          if (highlightedOrderId) {
            tr.classList.add('tr-highlight');
            updateChartHighlight(highlightedOrderId);
          } else {
            updateChartHighlight(null);
            if (chartInstance) {
              chartInstance.data.datasets[0].pointRadius = chartInstance.data.datasets[0].data.map(() => 5);
              chartInstance.data.datasets[1].pointRadius = chartInstance.data.datasets[1].data.map(() => 5);
              chartInstance.setActiveElements([]);
              chartInstance.update();
            }
          }
        };
      });
    }
    function onTableRowClick(e) {
      if (selectedCardRow == null) return;
      const tr = e.target.closest('tr.tr-selectable');
      if (!tr) return;
      const cb = tr.querySelector('input[type="checkbox"]');
      if (!cb) return;
      if (e.target.tagName === 'INPUT' && e.target.type === 'checkbox') {
        tr.classList.toggle('tr-selected', e.target.checked);
        return;
      }
      cb.checked = !cb.checked;
      tr.classList.toggle('tr-selected', cb.checked);
    }

    async function loadOrders() {
      hideError();
      document.body.classList.add('loading');
      try {
        const req = getReq();
        const res = await fetch(`${API_URL}/api/Binace/GetOrderMarginCross`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(req)
        });
        const data = await res.json().catch(() => ({}));
        if (!res.ok) {
          showError(data.message || `HTTP ${res.status}`);
          return;
        }
        if (!data.success) {
          showError(data.message || 'Request failed');
          return;
        }
        const rawOrders = data.orders || [];
        const orders = rawOrders.filter(o => (o.status || '').toUpperCase() !== 'CANCELED');
        lastOrders = orders;
        renderTable(orders, selectedCardRow !== null);
        updateSummary(orders);
        updateChart(orders);
        bindTableRowHighlight();
      } catch (err) {
        showError(err.message || 'Network error. Is the API running at ' + API_URL + '?');
      } finally {
        document.body.classList.remove('loading');
      }
    }

    el.btnNewSummary.addEventListener('click', () => {
      sum1.push({ row: sum1.length, totalQuantity: 0, priceAvgBuy: 0, priceAvgSell: 0, selectedOrderIds: [] });
      saveSum1();
      renderSummaryCards();
    });
    document.getElementById('btn-export-excel').addEventListener('click', exportToExcel);
    document.getElementById('btn-export-csv').addEventListener('click', exportToCsv);
    document.getElementById('btn-reset-zoom').addEventListener('click', () => {
      if (chartInstance && typeof chartInstance.resetZoom === 'function') chartInstance.resetZoom();
    });
    document.getElementById('chk-match-pairs').addEventListener('change', function() {
      showMatchedPairs = this.checked;
      renderTable(lastOrders, selectedCardRow !== null);
    });
    document.getElementById('btn-search').addEventListener('click', loadOrders);
    el.tbody.addEventListener('click', onTableRowClick);
    loadSum1();
    renderSummaryCards();
    loadOrders();
  </script>
</body>
</html>
